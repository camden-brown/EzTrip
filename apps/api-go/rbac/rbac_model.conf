# ====================================================================================
# CASBIN RBAC MODEL CONFIGURATION
# ====================================================================================
# This file defines how Casbin evaluates authorization requests.
# 
# Quick Reference:
#   r = Request (what someone is trying to do)
#   p = Policy (the permission rules)
#   g = Grouping (role assignments)
#   m = Matcher (the logic to evaluate requests)
#   e = Effect (how to combine multiple matches)
#
# Example Usage:
#   enforcer.Enforce("auth0|123", "users", "read")
#     → r.sub = "auth0|123" (WHO)
#     → r.obj = "users"     (WHAT resource)
#     → r.act = "read"      (WHAT action)
# ====================================================================================

# ------------------------------------------------------------------------------------
# REQUEST DEFINITION
# ------------------------------------------------------------------------------------
# Defines the parameters of an access request.
#
# Format: r = sub, obj, act
#   sub (subject)  = WHO is making the request (user ID, e.g., "auth0|123")
#   obj (object)   = WHAT resource they want to access (e.g., "users", "posts")
#   act (action)   = WHAT they want to do with it (e.g., "read", "write", "delete")
#
# Example: enforcer.Enforce("auth0|123", "users", "write")
#   → r.sub = "auth0|123"
#   → r.obj = "users"
#   → r.act = "write"
# ------------------------------------------------------------------------------------
[request_definition]
r = sub, obj, act

# ------------------------------------------------------------------------------------
# POLICY DEFINITION
# ------------------------------------------------------------------------------------
# Defines the structure of permission rules stored in the database.
#
# Format: p = sub, obj, act
#   sub = Role name (e.g., "admin", "user", "editor")
#   obj = Resource (e.g., "users", "posts", "*" for all)
#   act = Action (e.g., "read", "write", "*" for all)
#
# Example policies in database (casbin_rule table):
#   p, admin, *, *              → Admin can do anything on any resource
#   p, editor, posts, *         → Editor can do anything with posts
#   p, user, users, read        → User can read users
#   p, user, currentUser, *     → User can do anything with their own profile
# ------------------------------------------------------------------------------------
[policy_definition]
p = sub, obj, act

# ------------------------------------------------------------------------------------
# ROLE DEFINITION (Grouping)
# ------------------------------------------------------------------------------------
# Defines how users are assigned to roles.
#
# Format: g = _, _
#   First _  = User ID (e.g., "auth0|123456")
#   Second _ = Role name (e.g., "admin", "user")
#
# Example role assignments in database (casbin_rule table):
#   g, auth0|123456, admin      → User "auth0|123456" has "admin" role
#   g, auth0|789012, user       → User "auth0|789012" has "user" role
#
# Note: The g() function checks if a user has a role:
#   g(r.sub, p.sub) → "Does the requesting user have the role in the policy?"
# ------------------------------------------------------------------------------------
[role_definition]
g = _, _

# ------------------------------------------------------------------------------------
# POLICY EFFECT
# ------------------------------------------------------------------------------------
# Defines how to combine results when multiple policies match.
#
# Format: some(where (p.eft == allow))
#   Meaning: "Allow if ANY matching policy allows it" (OR logic)
#
# Other options (not used here):
#   - !some(where (p.eft == deny))  → "Deny if ANY policy denies"
#   - some(where (p.eft == allow)) && !some(where (p.eft == deny))  → "Deny-override"
#
# Our choice: If any policy says "allow", access is granted.
# ------------------------------------------------------------------------------------
[policy_effect]
e = some(where (p.eft == allow))

# ------------------------------------------------------------------------------------
# MATCHER
# ------------------------------------------------------------------------------------
# The core logic that determines if a request matches a policy.
#
# Format: g(r.sub, p.sub) && (p.obj == "*" || r.obj == p.obj) && (p.act == "*" || r.act == p.act)
#
# Breaking it down:
#
#   1. g(r.sub, p.sub)
#      → Does the requesting user have the role required by the policy?
#      → Example: Does "auth0|123" have role "admin"?
#
#   2. && (AND operator)
#
#   3. (p.obj == "*" || r.obj == p.obj)
#      → Either:
#        - Policy allows ALL resources (wildcard "*"), OR
#        - Requested resource matches policy resource exactly
#      → Example: Policy has "*" OR request for "users" matches policy "users"
#
#   4. && (AND operator)
#
#   5. (p.act == "*" || r.act == p.act)
#      → Either:
#        - Policy allows ALL actions (wildcard "*"), OR
#        - Requested action matches policy action exactly
#      → Example: Policy has "*" OR request for "write" matches policy "write"
#
# COMPLETE EXAMPLE:
#   Request: enforcer.Enforce("auth0|123", "users", "write")
#   Role:    g, auth0|123, admin
#   Policy:  p, admin, *, *
#
#   Evaluation:
#     1. g("auth0|123", "admin")        → ✅ YES (user has admin role)
#     2. ("*" == "*" || "users" == "*") → ✅ YES (policy allows all resources)
#     3. ("*" == "*" || "write" == "*") → ✅ YES (policy allows all actions)
#   
#   Result: ✅ ALLOWED
#
# WILDCARD EXAMPLES:
#   - admin, *, *           → Admin can do anything
#   - editor, posts, *      → Editor can do anything with posts
#   - viewer, *, read       → Viewer can read anything
#   - user, currentUser, *  → User can do anything with their own profile
# ------------------------------------------------------------------------------------
[matchers]
m = g(r.sub, p.sub) && (p.obj == "*" || r.obj == p.obj) && (p.act == "*" || r.act == p.act)
